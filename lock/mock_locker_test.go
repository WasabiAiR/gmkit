// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package lock

import (
	"sync"
	"time"
)

var (
	lockLockerMockLock   sync.RWMutex
	lockLockerMockUnlock sync.RWMutex
)

// Ensure, that LockerMock does implement Locker.
// If this is not the case, regenerate this file with moq.
var _ Locker = &LockerMock{}

// LockerMock is a mock implementation of Locker.
//
//     func TestSomethingThatUsesLocker(t *testing.T) {
//
//         // make and configure a mocked Locker
//         mockedLocker := &LockerMock{
//             LockFunc: func(name string, uniqueID string, duration time.Duration) (bool, error) {
// 	               panic("mock out the Lock method")
//             },
//             UnlockFunc: func(name string, uniqueID string) error {
// 	               panic("mock out the Unlock method")
//             },
//         }
//
//         // use mockedLocker in code that requires Locker
//         // and then make assertions.
//
//     }
type LockerMock struct {
	// LockFunc mocks the Lock method.
	LockFunc func(name string, uniqueID string, duration time.Duration) (bool, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func(name string, uniqueID string) error

	// calls tracks calls to the methods.
	calls struct {
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// Name is the name argument value.
			Name string
			// UniqueID is the uniqueID argument value.
			UniqueID string
			// Duration is the duration argument value.
			Duration time.Duration
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
			// Name is the name argument value.
			Name string
			// UniqueID is the uniqueID argument value.
			UniqueID string
		}
	}
}

// Lock calls LockFunc.
func (mock *LockerMock) Lock(name string, uniqueID string, duration time.Duration) (bool, error) {
	if mock.LockFunc == nil {
		panic("LockerMock.LockFunc: method is nil but Locker.Lock was just called")
	}
	callInfo := struct {
		Name     string
		UniqueID string
		Duration time.Duration
	}{
		Name:     name,
		UniqueID: uniqueID,
		Duration: duration,
	}
	lockLockerMockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	lockLockerMockLock.Unlock()
	return mock.LockFunc(name, uniqueID, duration)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//     len(mockedLocker.LockCalls())
func (mock *LockerMock) LockCalls() []struct {
	Name     string
	UniqueID string
	Duration time.Duration
} {
	var calls []struct {
		Name     string
		UniqueID string
		Duration time.Duration
	}
	lockLockerMockLock.RLock()
	calls = mock.calls.Lock
	lockLockerMockLock.RUnlock()
	return calls
}

// Unlock calls UnlockFunc.
func (mock *LockerMock) Unlock(name string, uniqueID string) error {
	if mock.UnlockFunc == nil {
		panic("LockerMock.UnlockFunc: method is nil but Locker.Unlock was just called")
	}
	callInfo := struct {
		Name     string
		UniqueID string
	}{
		Name:     name,
		UniqueID: uniqueID,
	}
	lockLockerMockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	lockLockerMockUnlock.Unlock()
	return mock.UnlockFunc(name, uniqueID)
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//     len(mockedLocker.UnlockCalls())
func (mock *LockerMock) UnlockCalls() []struct {
	Name     string
	UniqueID string
} {
	var calls []struct {
		Name     string
		UniqueID string
	}
	lockLockerMockUnlock.RLock()
	calls = mock.calls.Unlock
	lockLockerMockUnlock.RUnlock()
	return calls
}
